
通过初步思考，可以发现 $a$ 一定在 $\{x_i\}$ 内， $b$ 一定在 $\{y_i\}$ 内。接下来可以考虑从小到大枚举每一个 $a$，则那些二元组 $(x,y),x\ge a$ 的权值全部由 $a$ 贡献，只需要考虑 $b$ 的取值。
从小到大枚举到第 $k$ 个 $x_i$ ，记集合 $B=\{y\mid y_i,i<k\}$ 也就是不能由 $a$ 作为贡献的二元组的 $y$ 关键字。在 $B$ 内找一个值作为 $b$，则贡献就是 $pb$，其中 $p$ 为集合 $x\in B,x\ge b$ 的元素 $x$ 的个数。
按照套路考虑在集合上按照值域建立一个数据结构，每一个位置维护值 $val_i$ 表示集合内有多少元素大于等于当前位置的值 $w_i$。考虑每当 $k+1$ 的时候，需要将当前二元组 $(x_i,y_i)$ 的 $y_i$ 加入集合 $B$，也就是对区间 $[1,y_i]$ 进行区间 $+1$ 操作。这似乎不能直接做，因为每个位置需要维护贡献 $val_iw_i$，乘积不一定。
这种问题考虑单调性或斜率优化。
具体地对区间进行<strong>分块</strong>处理。对于每一个区间，记我们要求的贡献为 $A=\max(val_i\times w_i)$。
### sol1
对整块的区间进行若干次加法操作就变成了 $A=\max((val_i+t)\times w_i)$，其中 $t$ 为对当前整块区间整体加一的次数。进行<strong>斜率优化</strong>，转化为 $-val_i\times w_i=t\times w_i-A$，视自变量为 $w_i$，因变量为 $-val_iw_i$，则斜率为 $t$，即求截距 $-A$ 的最小值就能得到 $A$ 的最大值。因为 $t$ 是单调的，直接使用<strong>单调队列维护下凸壳</strong>即可。
对于散块，考虑重新构建当前块，也就是清算每个位置的 $val_iw_i\leftarrow (val_i+t)w_i$ 并施 $t=0$。重新构建新的下凸壳即可。
这样进行一个 $k$ 的移动会修改 $O(\sqrt n)$ 个块，每个块都只用单调队列维护凸包，而重构块只有 $O(n)$ 次，总共只会重构并且在所有单调队列中出现 $O(n\sqrt n)$ 个元素，故时间复杂度为 $O(n\sqrt n)$。
期望得分：$\ge 90$

### sol2
问题转化成维护若干个一次函数和它们的最值，支持一个区间的 $x+1$，求一个区间的函数最值。考虑使用 KTT，对于每个点，维护它当前取得最值的一次函数 $r$ 以及一个阈值 $t$，表示 $x$ 至少还要增加多少才能使子树内某个 $r$ 的斜率。发生改变。$t$ 的取值有两种情况：左右儿子的 $t$ 和 左右儿子的 $r$ 的交点（经过交点之后大小关系就改变了），这显然是可以 update 的时候直接算出来的。
对于一次修改，如果增加的值 $\le t$ 则当前 $r$ 不变，否则暴力往下递归修改。复杂度证明可以设一个点的势能为 $dep\times ([k_r<k_{ls_r}]+[k_r<k_{rs_r}])$，每次暴力往下递归都会减少至少 $1$ 的势能，且势能被减少之后永远不会再增加回来。复杂度 $O(n\log ^2n+q\log n)$
期望得分： $100$