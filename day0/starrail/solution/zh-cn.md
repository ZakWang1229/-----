
通过初步思考，可以发现 $a$ 一定在 $\{x_i\}$ 内， $b$ 一定在 $\{y_i\}$ 内。接下来可以考虑从小到大枚举每一个 $a$，则那些二元组 $(x,y),x\ge a$ 的权值全部由 $a$ 贡献，只需要考虑 $b$ 的取值。
从小到大枚举到第 $k$ 个 $x_i$ ，记集合 $B=\{y\mid y_i,i<k\}$ 也就是不能由 $a$ 作为贡献的二元组的 $y$ 关键字。在 $B$ 内找一个值作为 $b$，则贡献就是 $pb$，其中 $p$ 为集合 $x\in B,x\ge b$ 的元素 $x$ 的个数。
按照套路考虑在集合上按照值域建立一个数据结构，每一个位置维护值 $val_i$ 表示集合内有多少元素大于等于当前位置的值 $w_i$。考虑每当 $k+1$ 的时候，需要将当前二元组 $(x_i,y_i)$ 的 $y_i$ 加入集合 $B$，也就是对区间 $[1,y_i]$ 进行区间 $+1$ 操作。这似乎不能直接做，因为每个位置需要维护贡献 $val_iw_i$，乘积不一定。
这种问题考虑单调性或斜率优化。具体地对区间进行<strong>分块</strong>处理。对于每一个区间，记我们要求的贡献为 $A=\max(val_i\times w_i)$。
对整块的区间进行若干次加法操作就变成了 $A=\max((val_i+t)\times w_i)$，其中 $t$ 为对当前整块区间整体加一的次数。进行<strong>斜率优化</strong>，转化为 $-val_i\times w_i=t\times w_i-A$，视自变量为 $w_i$，因变量为 $-val_iw_i$，则斜率为 $t$，即求截距 $-A$ 的最小值就能得到 $A$ 的最大值。因为 $t$ 是单调的，直接使用<strong>单调队列维护下凸壳</strong>即可。
对于散块，考虑重新构建当前块，也就是清算每个位置的 $val_iw_i\leftarrow (val_i+t)w_i$ 并施 $t=0$。重新构建新的下凸壳即可。
这样进行一个 $k$ 的移动会修改 $O(\sqrt n)$ 个块，每个块都只用单调队列维护凸包，而重构块只有 $O(n)$ 次，总共只会重构并且在所有单调队列中出现 $O(n\sqrt n)$ 个元素，故时间复杂度为 $O(n\sqrt n)$。